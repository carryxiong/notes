## tcp断开连接时需要四次挥手的原因

1. tcp是全双工通道，通信双方都可以独立关闭自己的通信通道，也就是半关闭。

2. client先发送FIN告知对方我已经完成数据发送了，server回复ack来确定我知道了。这样一个流程，就关闭了client的发送信息通道。但是还可以接收来自server方的数据。

3. server此时已经知道接收不到client的数据了，但是还可以给它发送数据。如果server也没有啥数据要发送给对方了，server也会以FIN标志位发送一个信息给client，client接到后，也会传递一个ack表示知道了。这样子，双方都完成了关闭。
![](https://img2018.cnblogs.com/blog/1690472/202002/1690472-20200204225708687-1180454832.png)

## 四次挥手 ##
1. 客户端数据发送完成，则它向服务端发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，客户端将进入FIN-WAIT-1状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2. 服务器收到客户端连接释放报文，通知相应的高层应用进程，告诉它客户端向服务器这个方向的连接已经释放了。此时服务端进入了CLOSE-WAIT（关闭等待）状态，并向客户端发出连接释放的应答，其报文头包含：ACK=1，ack=u+1，seq=v。客户端收到该应答后，进入FIN-WAIT-2状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。第二次挥手完成后，客户端到服务端方向的连接已经释放，服务端不会再接收客户端的数据，客户端也没有数据要发送了。但服务端到客户端方向的连接仍然存在，服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3. 服务端将最后的数据发送完毕后，就向客户端发送连接释放报文，其报文头包含：FIN=1，ack=u+1，由于在CLOS-WAIT状态，服务端很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

4. 客户端收到服务器的连接释放报文后，向服务端发出确认应答，报文头：ACK=1，ack=w+1，seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。该状态会持续2MSL（最长报文段寿命）时间，这个期间TCP连接还未释放，若该时间段内没有服务端的重发请求的话，客户端就进入CLOSED状态，服务端只要收到了客户端发出的确认，立即进入CLOSED状态。就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

 ### 服务器中出现了大量的closewait状态的原因

client已经关闭了socket连接，而我方忙于读或写，没有及时的去关闭连接。

### 	         解决办法 
1. 检查代码，特别是释放资源的代码。
2. 检查配置，特别是处理请求的线程配置。