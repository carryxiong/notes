# java虚拟机对锁的优化 #
1. 自旋锁和自适应
自旋锁就是一般利用循环和cas来实现的，但是自旋锁我们知道它的缺点就是如果你一直拿不到这个锁的话，他就会一直去执行cas尝试获取锁，也就是说如果长时间拿不到锁，性能会很低。为了解决这个问题呢，就是自适应了，什么是自适应呢？就是说比如你尝试获取了100次都不能获取到，那么他自己会适应，不再尝试获取自旋锁，而是直接进入阻塞状态，这样的话，就没有那么多的浪费了，当然这其中是有个度的，比如你稍微多等下，就拿到锁的话，那么就不用进入阻塞了，所以这个自适应主要还是解决长时间的自旋问题的。
2. 锁消除
锁消除指的是，如果你对临界区的资源进行保护，但是这个资源根本就不是临界区的资源，也就是说这个资源根本不会有线程安全的问题，那么就是说，我们根本就不需要进行加锁这个操作，就可以去掉锁，就是锁消除。
3. 锁粗化
一般，我们都是让同步代码块越小越好，这样被保护起来的代码就少，那么久可以提高效率，但是有时候我们需要让被保护的代码块越大越好，比如说，我们两个代码块用了同一个锁，synchronized用的是同一把锁，那么虚拟机就会将这两个代码块合并为一个大的代码块，因为这样的话，就避免了重复的加锁解锁过程。一次加锁解锁就能解决的问题为啥要多次呢？这就是锁粗化。


**************
#我们在写代码时如何优化锁和提高并发性能
1. **缩小同步代码块**
锁住我们需要锁的部分，把其他不想关的，开销大的不要包括在内
2. **尽量不要锁住方法**
对于一个方法，可能我们并不需要那么大的范围，并且可能以后我们需要修改这个方法，往里面添加代码，那么可能就不需要锁住的内容被锁住。
3. **减少请求锁的次数**
4. **避免人为制造热点**
5. **锁中不要再包含锁**
容易造成死锁
6. **选择合适的锁类型或合适的工具类。**