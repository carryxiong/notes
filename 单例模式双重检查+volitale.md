#对于在单例模式中，双重检查用上synchronized以后为什么还要加volitale修饰
	对于这个问题，看了蛮多博客，资料，感觉自己有了比较靠谱的回答，也可以解释自己所有的疑惑，我认为还是可以认同的。
	
```
	public class Singleton {
    
    private static volatile Singleton instance;
    
    public static Singleton getInstance()
    {
        if(instance ==null)
        {
            synchronized (Singleton.class)
            {
                if(instance ==null)
                    instance =new Singleton();
            }
        }
        return instance;
    }
}
```
看到代码，我对于其中已经用synchronized关键字修饰的部分，就是已经用了synchronized，为什么还必须要加上volitale，毕竟volitale号称小synchronized。
1. 对于volitale可以保证可见性和禁止指令重排序，但不保证原子性，我们一般说synchronized这三个性质都满足，但是，认为synchronized的同步原理是对于同步代码块的代码来说，我们是无法保证同步代码内部的重排序，也就是内存屏障是同步代码之前的代码都是满足该发生的都发生了，happens-before原则，对于内部代码是可能发生重排序的。这就会导致在我们对instance实例化的时候可以发生错误。
2. new 一个对象首先开辟内存空间，然后调用构造方法初始化内部，最后返回一个引用给这个instance，如果在这里，发生了重排序，也就是开辟内存空间以后，还没有初始化，就把引用返回了，那么这个时候这个instance引用持有的对象指向的空间存在，但是内部初始化的工作还没有完成。
3. 那么问题来了，在我们的第一个线程执行到new Singleton（）这里发生重排序，instance拿到了引用，虽然没有值，这个时候，我们的第二个线程也想要获取一个instance，调用getInstance方法，那么就会首先判断if（instance==null）这是我们第一次判断是否为null，那么在这个时候判断得到的结果就是不为空，就会直接返回这个instance实例，那么这个线程拿到这个对象做什么事情就会报错，报空指针异常，因为这个对象内部还没有初始化好。
4. 所以我们加上volitale就不会在我们new的过程发生重排序，就不会有这样的bug。
以上就是我对于一些资料的总结理解。

##关于synchronized的一些理解
我们知道它可以保护我们的代码，就是加锁，那么我们的多个线程执行代码，一个线程拿到了同步代码的锁，别的方法就无法进入，那么就可以说这个同步块中的代码每次都是只有一个线程在执行，所以就可以起到避免多线程一起执行，变成一个单线程一样，大家每次都是只有一个人在执行这个代码，不就变成单线程了吗。这样就起到了同步的作用，对于上面的代码为什么不能保证有序性呢，因为这第一个if判断不是在我们的同步代码块中啊，synchronized如何可以保护他呢？如果在我们的代码中就不会出现这种情况，因为第二个线程根本拿不到锁，不能进入我们的代码块中，也就无法出现if判断，必须等到我们new对象全部完成了以后，就算中间出现了重排序，第二个线程也无法利用这个没有初始化好的对象引用来做任何事，而且发现了吗？就是如果第一个if也进入我们的同步代码块中，那么这个双重检查没有任何意义，这个synchronized相当于直接加在我们的方法之上，我们之前想要的就是提高效率，才会出现第一个if，如果已经实例化好，就直接返回，不需要每次都拿到这个锁，效率太低，所以我们在这样的情况下，才会需要一个volitale来保护我们的第一个if语句。
结论：synchronized不能防止重排序，但是可以保证有序性，因为是块中的结果无论怎么重排序，对于其他线程而言都是一致的。